diff --git a/src/Makefile b/src/Makefile
index ecbd275..93572ed 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -17,14 +17,14 @@ uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')
 uname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')
 CLANG := $(findstring clang,$(shell sh -c '$(CC) --version | head -1'))
 OPTIMIZATION?=-O3
-ifeq ($(OPTIMIZATION),-O3)
-	ifeq (clang,$(CLANG))
-		REDIS_CFLAGS+=-flto
-	else
-		REDIS_CFLAGS+=-flto=auto
-	endif
-	REDIS_LDFLAGS+=-O3 -flto
-endif
+# ifeq ($(OPTIMIZATION),-O3)
+# 	ifeq (clang,$(CLANG))
+# 		REDIS_CFLAGS+=-flto
+# 	else
+# 		REDIS_CFLAGS+=-flto=auto
+# 	endif
+# 	REDIS_LDFLAGS+=-O3 -flto
+# endif
 DEPENDENCY_TARGETS=hiredis linenoise lua hdr_histogram fpconv
 NODEPS:=clean distclean

diff --git a/src/blocked.c b/src/blocked.c
index 6ad4667..62087f3 100644
--- a/src/blocked.c
+++ b/src/blocked.c
@@ -569,8 +569,7 @@ static void handleClientsBlockedOnKey(readyList *rl) {

         /* Avoid processing more than the initial count so that we're not stuck
          * in an endless loop in case the reprocessing of the command blocks again. */
-        long count = listLength(clients);
-        while ((ln = listNext(&li)) && count--) {
+        while ((ln = listNext(&li))) {
             client *receiver = listNodeValue(ln);
             robj *o = lookupKeyReadWithFlags(rl->db, rl->key, LOOKUP_NOEFFECTS);
             /* 1. In case new key was added/touched we need to verify it satisfy the
diff --git a/src/debug.c b/src/debug.c
index 684f692..1ac8296 100644
--- a/src/debug.c
+++ b/src/debug.c
@@ -1158,6 +1158,8 @@ void _serverPanic(const char *file, int line, const char *msg, ...) {
         printCrashReport();
     }

+    fprintf(stderr, "FAULT: %lld\n", ustime());
+
     // remove the signal handler so on abort() we will output the crash report.
     removeSignalHandlers();
     bugReportEnd(0, 0);
@@ -2168,6 +2170,8 @@ void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
         dumpCodeAroundEIP(eip);
 #endif

+    fprintf(stderr, "FAULT: %lld\n", ustime());
+
     bugReportEnd(1, sig);
 }

diff --git a/src/server.c b/src/server.c
index 438325f..3173603 100644
--- a/src/server.c
+++ b/src/server.c
@@ -3756,6 +3756,15 @@ int commandCheckExistence(client *c, sds *err) {
         return 1;
     if (!err)
         return 0;
+    // phx
+    /* if (!strcasecmp(c->argv[0]->ptr, "get|")) {
+        addReplySubcommandSyntaxError(c);
+        return C_OK;
+    } */
+    if (lookupCommandBySds(c->argv[0]->ptr)) {
+        addReplySubcommandSyntaxError(c);
+        return C_OK;
+#if 0
     if (isContainerCommandBySds(c->argv[0]->ptr)) {
         /* If we can't find the command but argv[0] by itself is a command
          * it means we're dealing with an invalid subcommand. Print Help. */
@@ -3765,6 +3774,7 @@ int commandCheckExistence(client *c, sds *err) {
         *err = sdscatprintf(*err, "unknown subcommand '%.128s'. Try %s HELP.",
                             (char *)c->argv[1]->ptr, cmd);
         sdsfree(cmd);
+#endif
     } else {
         sds args = sdsempty();
         int i;
@@ -6483,6 +6493,8 @@ int changeListener(connListener *listener) {
 static void sigShutdownHandler(int sig) {
     char *msg;

+    fprintf(stderr, "FAULT: %lld\n", ustime());
+
     switch (sig) {
     case SIGINT:
         msg = "Received SIGINT scheduling shutdown...";
@@ -6511,6 +6523,14 @@ static void sigShutdownHandler(int sig) {
     server.last_sig_received = sig;
 }

+void phx_segfault_test(int sig, siginfo_t *info, void *secret) {
+    UNUSED(secret);
+    UNUSED(info);
+    (void)sig;
+    fprintf(stderr, "FAULT: %lld\n", ustime());
+    _exit(1);
+}
+
 void setupSignalHandlers(void) {
     struct sigaction act;

@@ -6526,12 +6546,15 @@ void setupSignalHandlers(void) {
     act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
     act.sa_sigaction = sigsegvHandler;
     if(server.crashlog_enabled) {
-        sigaction(SIGSEGV, &act, NULL);
+        // sigaction(SIGSEGV, &act, NULL);
         sigaction(SIGBUS, &act, NULL);
         sigaction(SIGFPE, &act, NULL);
         sigaction(SIGILL, &act, NULL);
         sigaction(SIGABRT, &act, NULL);
     }
+    act.sa_sigaction = phx_segfault_test;
+    sigaction(SIGSEGV, &act, NULL);
+
     return;
 }

@@ -6832,8 +6855,9 @@ void loadDataFromDisk(void) {
 void redisOutOfMemoryHandler(size_t allocation_size) {
     serverLog(LL_WARNING,"Out Of Memory allocating %zu bytes!",
         allocation_size);
-    serverPanic("Redis aborting for OUT OF MEMORY. Allocating %zu bytes!",
-        allocation_size);
+    phx_segfault_test(SIGSEGV,NULL,NULL);
+    // serverPanic("Redis aborting for OUT OF MEMORY. Allocating %zu bytes!",
+    //     allocation_size);
 }

 /* Callback for sdstemplate on proc-title-template. See redis.conf for
@@ -7036,6 +7060,8 @@ int main(int argc, char **argv) {
     int j;
     char config_from_stdin = 0;

+    fprintf(stderr, "RESTART: %lld\n", ustime());
+
 #ifdef REDIS_TEST
     if (argc >= 3 && !strcasecmp(argv[1], "test")) {
         int flags = 0;
@@ -7357,6 +7383,7 @@ int main(int argc, char **argv) {
     redisSetCpuAffinity(server.server_cpulist);
     setOOMScoreAdj(-1);

+    fprintf(stderr, "NEWREQ: %lld\n", ustime());
     aeMain(server.el);
     aeDeleteEventLoop(server.el);
     return 0;
diff --git a/src/t_zset.c b/src/t_zset.c
index 7717a4a..be2b509 100644
--- a/src/t_zset.c
+++ b/src/t_zset.c
@@ -2593,7 +2593,8 @@ void zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, in
     }

     /* test if the expected number of keys would overflow */
-    if (setnum > (c->argc-(numkeysIndex+1))) {
+    // if (setnum > (c->argc-(numkeysIndex+1))) {
+    if (setnum+(numkeysIndex+1) > c->argc) {
         addReplyErrorObject(c,shared.syntaxerr);
         return;
     }
