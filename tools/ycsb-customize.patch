diff --git a/bin/ycsb b/bin/ycsb
index b5c85e35..ccae5004 100755
--- a/bin/ycsb
+++ b/bin/ycsb
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 #
 # Copyright (c) 2012 - 2020 YCSB contributors. All rights reserved.
 #
@@ -16,6 +16,7 @@
 # LICENSE file.
 #
 
+from __future__ import print_function
 import errno
 import fnmatch
 import io
@@ -28,7 +29,7 @@ try:
     mod = __import__('argparse')
     import argparse
 except ImportError:
-    print >> sys.stderr, '[ERROR] argparse not found. Try installing it via "pip".'
+    print('[ERROR] argparse not found. Try installing it via "pip".', file=sys.stderr)
     exit(1)
 
 BASE_URL = "https://github.com/brianfrankcooper/YCSB/tree/master/"
@@ -116,27 +117,27 @@ OPTIONS = {
 }
 
 def usage():
-    output = io.BytesIO()
-    print >> output, "%s command database [options]" % sys.argv[0]
+    output = io.StringIO()
+    print(u"%s command database [options]" % sys.argv[0], file=output)
 
-    print >> output, "\nCommands:"
+    print(u"\nCommands:", file=output)
     for command in sorted(COMMANDS.keys()):
-        print >> output, "    %s %s" % (command.ljust(14),
-                                        COMMANDS[command]["description"])
+        print(u"    %s %s" % (command.ljust(14),
+                                        COMMANDS[command]["description"]), file=output)
 
-    print >> output, "\nDatabases:"
+    print(u"\nDatabases:", file=output)
     for db in sorted(DATABASES.keys()):
-        print >> output, "    %s %s" % (db.ljust(14), BASE_URL +
-                                        db.split("-")[0])
+        print(u"    %s %s" % (db.ljust(14), BASE_URL +
+                                        db.split("-")[0]), file=output)
 
-    print >> output, "\nOptions:"
+    print(u"\nOptions:", file=output)
     for option in sorted(OPTIONS.keys()):
-        print >> output, "    %s %s" % (option.ljust(14), OPTIONS[option])
+        print(u"    %s %s" % (option.ljust(14), OPTIONS[option]), file=output)
 
-    print >> output, """\nWorkload Files:
+    print(u"""\nWorkload Files:
     There are various predefined workloads under workloads/ directory.
     See https://github.com/brianfrankcooper/YCSB/wiki/Core-Properties
-    for the list of workload properties."""
+    for the list of workload properties.""", file=output)
 
     return output.getvalue()
 
@@ -172,18 +173,18 @@ def check_output(*popenargs, **kwargs):
         if cmd is None:
             cmd = popenargs[0]
         error = subprocess.CalledProcessError(retcode, cmd)
-        error.output = output
+        error.output = output.decode()
         raise error
-    return output
+    return output.decode()
 
 def debug(message):
-    print >> sys.stderr, "[DEBUG] ", message
+    print("[DEBUG] ", message, file=sys.stderr)
 
 def warn(message):
-    print >> sys.stderr, "[WARN] ", message
+    print("[WARN] ", message, file=sys.stderr)
 
 def error(message):
-    print >> sys.stderr, "[ERROR] ", message
+   print("[ERROR] ", message, file=sys.stderr)
 
 def find_jars(dir, glob='*.jar'):
     jars = []
@@ -220,7 +221,7 @@ def get_classpath_from_maven(module):
         # the last module will be the datastore binding
         line = [x for x in mvn_output.splitlines() if x.startswith("classpath=")][-1:]
         return line[0][len("classpath="):]
-    except subprocess.CalledProcessError, err:
+    except subprocess.CalledProcessError as err:
         error("Attempting to generate a classpath from Maven failed "
               "with return code '" + str(err.returncode) + "'. The output from "
               "Maven follows, try running "
@@ -311,7 +312,7 @@ def main():
                      main_classname, "-db", db_classname] + remaining)
     if command:
         ycsb_command.append(command)
-    print >> sys.stderr, " ".join(ycsb_command)
+    print(" ".join(ycsb_command), file=sys.stderr)
     try:
         return subprocess.call(ycsb_command)
     except OSError as e:
diff --git a/core/src/main/java/site/ycsb/DBWrapper.java b/core/src/main/java/site/ycsb/DBWrapper.java
index 60e96c20..01657432 100644
--- a/core/src/main/java/site/ycsb/DBWrapper.java
+++ b/core/src/main/java/site/ycsb/DBWrapper.java
@@ -178,7 +178,11 @@ public class DBWrapper extends DB {
           this.latencyTrackedErrors.contains(result.getName())) {
         measurementName = op + "-" + result.getName();
       } else {
-        measurementName = op + "-FAILED";
+        if (result.isMissed()) {
+          measurementName = op + "-MISSED";
+        } else {
+          measurementName = op + "-FAILED";
+        }
       }
     }
     measurements.measure(measurementName,
diff --git a/core/src/main/java/site/ycsb/Status.java b/core/src/main/java/site/ycsb/Status.java
index 8a27cc93..a8ecd1ca 100644
--- a/core/src/main/java/site/ycsb/Status.java
+++ b/core/src/main/java/site/ycsb/Status.java
@@ -93,8 +93,16 @@ public class Status {
     return this == OK || this == BATCHED_OK;
   }
 
+  /**
+   * Return true if the status is MISSED.
+   */
+  public boolean isMissed() {
+    return this == MISSED;
+  }
+
   public static final Status OK = new Status("OK", "The operation completed successfully.");
   public static final Status ERROR = new Status("ERROR", "The operation failed.");
+  public static final Status MISSED = new Status("MISSED", "Cache Miss.");
   public static final Status NOT_FOUND = new Status("NOT_FOUND", "The requested record was not found.");
   public static final Status NOT_IMPLEMENTED = new Status("NOT_IMPLEMENTED", "The operation is not " +
       "implemented for the current binding.");
diff --git a/redis/src/main/java/site/ycsb/db/RedisClient.java b/redis/src/main/java/site/ycsb/db/RedisClient.java
index 2de9ad23..a7522e86 100644
--- a/redis/src/main/java/site/ycsb/db/RedisClient.java
+++ b/redis/src/main/java/site/ycsb/db/RedisClient.java
@@ -29,18 +29,21 @@ import site.ycsb.DB;
 import site.ycsb.DBException;
 import site.ycsb.Status;
 import site.ycsb.StringByteIterator;
-import redis.clients.jedis.BasicCommands;
-import redis.clients.jedis.HostAndPort;
+// import redis.clients.jedis.BasicCommands;
+// import redis.clients.jedis.HostAndPort;
 import redis.clients.jedis.Jedis;
-import redis.clients.jedis.JedisCluster;
-import redis.clients.jedis.JedisCommands;
+// import redis.clients.jedis.JedisCluster;
+// import redis.clients.jedis.JedisCommands;
+import redis.clients.jedis.JedisPool;
 import redis.clients.jedis.Protocol;
+// import redis.clients.jedis.exceptions.JedisConnectionException;
 
 import java.io.Closeable;
+import java.io.FileWriter;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.HashSet;
+// import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Properties;
@@ -54,13 +57,15 @@ import java.util.Vector;
  */
 public class RedisClient extends DB {
 
-  private JedisCommands jedis;
+  private JedisPool jedisPool;
+  private FileWriter phxDumpPipe;
 
   public static final String HOST_PROPERTY = "redis.host";
   public static final String PORT_PROPERTY = "redis.port";
   public static final String PASSWORD_PROPERTY = "redis.password";
   public static final String CLUSTER_PROPERTY = "redis.cluster";
   public static final String TIMEOUT_PROPERTY = "redis.timeout";
+  public static final String PHX_DUMP_PIPE_PROPERTY = "redis.phxdumppipe";
 
   public static final String INDEX_KEY = "_indices";
 
@@ -76,6 +81,19 @@ public class RedisClient extends DB {
     }
     String host = props.getProperty(HOST_PROPERTY);
 
+    String phxDumpPipePath = props.getProperty(PHX_DUMP_PIPE_PROPERTY);
+    if (phxDumpPipePath != null) {
+      try {
+        this.phxDumpPipe = new FileWriter(phxDumpPipePath, true); // true for append mode
+      } catch (IOException e) {
+        throw new DBException("Failed to open phx dump pipe: " + e.getMessage());
+      }
+    } else {
+      System.err.println("phx dump pipe is not enabled");
+    }
+
+    jedisPool = new JedisPool(host, port);
+    /*
     boolean clusterEnabled = Boolean.parseBoolean(props.getProperty(CLUSTER_PROPERTY));
     if (clusterEnabled) {
       Set<HostAndPort> jedisClusterNodes = new HashSet<>();
@@ -95,11 +113,15 @@ public class RedisClient extends DB {
     if (password != null) {
       ((BasicCommands) jedis).auth(password);
     }
+    */
   }
 
   public void cleanup() throws DBException {
     try {
-      ((Closeable) jedis).close();
+      if (phxDumpPipe != null) {
+        phxDumpPipe.close();
+      }
+      ((Closeable) jedisPool).close();
     } catch (IOException e) {
       throw new DBException("Closing connection failed.");
     }
@@ -115,57 +137,111 @@ public class RedisClient extends DB {
     return key.hashCode();
   }
 
+  /**
+   * Write key and field data to the phx dump pipe with proper synchronization.
+   */
+  private synchronized void writeToPhxDumpPipe(String key, Map<String, String> values) {
+    if (phxDumpPipe == null) {
+      return;
+    }
+
+    try {
+      // Write the key line
+      phxDumpPipe.write("PHXKEY:" + key + "\n");
+
+      // Write each field
+      for (Map.Entry<String, String> entry : values.entrySet()) {
+        String fieldName = entry.getKey();
+        String fieldValue = entry.getValue();
+        phxDumpPipe.write("PHXFIELDNAME:" + fieldName + "\nPHXFIELDVALUE:" + fieldValue + "\n");
+      }
+
+      // Flush to ensure data is written immediately
+      phxDumpPipe.flush();
+    } catch (IOException e) {
+      // Log error but don't throw to avoid breaking the main operation
+      System.err.println("Error writing to phx dump pipe: " + e.getMessage());
+    }
+  }
+
   // XXX jedis.select(int index) to switch to `table`
 
   @Override
   public Status read(String table, String key, Set<String> fields,
       Map<String, ByteIterator> result) {
-    if (fields == null) {
-      StringByteIterator.putAllAsByteIterators(result, jedis.hgetAll(key));
-    } else {
-      String[] fieldArray =
-          (String[]) fields.toArray(new String[fields.size()]);
-      List<String> values = jedis.hmget(key, fieldArray);
+    try (Jedis jedis = jedisPool.getResource()) {
+      if (fields == null) {
+        StringByteIterator.putAllAsByteIterators(result, jedis.hgetAll(key));
+      } else {
+        String[] fieldArray =
+            (String[]) fields.toArray(new String[fields.size()]);
+        List<String> values = jedis.hmget(key, fieldArray);
 
-      Iterator<String> fieldIterator = fields.iterator();
-      Iterator<String> valueIterator = values.iterator();
+        Iterator<String> fieldIterator = fields.iterator();
+        Iterator<String> valueIterator = values.iterator();
 
-      while (fieldIterator.hasNext() && valueIterator.hasNext()) {
-        result.put(fieldIterator.next(),
-            new StringByteIterator(valueIterator.next()));
+        while (fieldIterator.hasNext() && valueIterator.hasNext()) {
+          result.put(fieldIterator.next(),
+              new StringByteIterator(valueIterator.next()));
+        }
+        assert !fieldIterator.hasNext() && !valueIterator.hasNext();
       }
-      assert !fieldIterator.hasNext() && !valueIterator.hasNext();
+      return result.isEmpty() ? Status.MISSED : Status.OK;
+    } catch (Exception e) {
+      return Status.ERROR;
     }
-    return result.isEmpty() ? Status.ERROR : Status.OK;
   }
 
   @Override
   public Status insert(String table, String key,
       Map<String, ByteIterator> values) {
-    if (jedis.hmset(key, StringByteIterator.getStringMap(values))
-        .equals("OK")) {
-      jedis.zadd(INDEX_KEY, hash(key), key);
-      return Status.OK;
+    try (Jedis jedis = jedisPool.getResource()) {
+      // Write to phx dump pipe before Redis operation
+      Map<String, String> valuesMap = StringByteIterator.getStringMap(values);
+      writeToPhxDumpPipe(key, valuesMap);
+
+      if (jedis.hmset(key, valuesMap)
+          .equals("OK")) {
+        // jedis.zadd(INDEX_KEY, hash(key), key);
+        return Status.OK;
+      }
+      return Status.ERROR;
+    } catch (Exception e) {
+      return Status.ERROR;
     }
-    return Status.ERROR;
   }
 
   @Override
   public Status delete(String table, String key) {
-    return jedis.del(key) == 0 && jedis.zrem(INDEX_KEY, key) == 0 ? Status.ERROR
-        : Status.OK;
+    try (Jedis jedis = jedisPool.getResource()) {
+      // TODO: write to phx dump pipe
+      return jedis.del(key) == 0 /* && jedis.zrem(INDEX_KEY, key) == 0 */ ? Status.ERROR
+          : Status.OK;
+    } catch (Exception e) {
+      return Status.ERROR;
+    }
   }
 
   @Override
   public Status update(String table, String key,
       Map<String, ByteIterator> values) {
-    return jedis.hmset(key, StringByteIterator.getStringMap(values))
-        .equals("OK") ? Status.OK : Status.ERROR;
+    try (Jedis jedis = jedisPool.getResource()) {
+      // Write to phx dump pipe before Redis operation
+      Map<String, String> valuesMap = StringByteIterator.getStringMap(values);
+      writeToPhxDumpPipe(key, valuesMap);
+
+      return jedis.hmset(key, valuesMap)
+          .equals("OK") ? Status.OK : Status.ERROR;
+    } catch (Exception e) {
+      return Status.ERROR;
+    }
   }
 
   @Override
   public Status scan(String table, String startkey, int recordcount,
       Set<String> fields, Vector<HashMap<String, ByteIterator>> result) {
+    return Status.ERROR;
+    /*
     Set<String> keys = jedis.zrangeByScore(INDEX_KEY, hash(startkey),
         Double.POSITIVE_INFINITY, 0, recordcount);
 
@@ -177,6 +253,7 @@ public class RedisClient extends DB {
     }
 
     return Status.OK;
+    */
   }
 
 }
